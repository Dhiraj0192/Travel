{
  "version": 3,
  "sources": ["../../html-truncate/lib/truncate.js"],
  "sourcesContent": ["/**\r\n * Truncate HTML string and keep tag safe.\r\n *\r\n * @method truncate\r\n * @param {String} string string needs to be truncated\r\n * @param {Number} maxLength length of truncated string\r\n * @param {Object} options (optional)\r\n * @param {Boolean} [options.keepImageTag] flag to specify if keep image tag, false by default\r\n * @param {Boolean} [options.truncateLastWord] truncates last word, true by default\r\n * @param {Number} [options.slop] tolerance when options.truncateLastWord is false before we give up and just truncate at the maxLength position, 10 by default (but not greater than maxLength)\r\n * @param {Boolean|String} [options.ellipsis] omission symbol for truncated string, '...' by default\r\n * @return {String} truncated string\r\n */\r\nfunction truncate(string, maxLength, options) {\r\n    var EMPTY_OBJECT = {},\r\n        EMPTY_STRING = '',\r\n        DEFAULT_TRUNCATE_SYMBOL = '...',\r\n        DEFAULT_SLOP = 10 > maxLength ? maxLength : 10,\r\n        EXCLUDE_TAGS = ['img', 'br'],   // non-closed tags\r\n        items = [],                     // stack for saving tags\r\n        total = 0,                      // record how many characters we traced so far\r\n        content = EMPTY_STRING,         // truncated text storage\r\n        KEY_VALUE_REGEX = '([\\\\w|-]+\\\\s*(=\\\\s*\"[^\"]*\")?\\\\s*)*',\r\n        IS_CLOSE_REGEX = '\\\\s*\\\\/?\\\\s*',\r\n        CLOSE_REGEX = '\\\\s*\\\\/\\\\s*',\r\n        SELF_CLOSE_REGEX = new RegExp('<\\\\/?\\\\w+\\\\s*' + KEY_VALUE_REGEX + CLOSE_REGEX + '>'),\r\n        HTML_TAG_REGEX = new RegExp('<\\\\/?\\\\w+\\\\s*' + KEY_VALUE_REGEX + IS_CLOSE_REGEX + '>'),\r\n        URL_REGEX = /(((ftp|https?):\\/\\/)[\\-\\w@:%_\\+.~#?,&\\/\\/=]+)|((mailto:)?[_.\\w\\-]+@([\\w][\\w\\-]+\\.)+[a-zA-Z]{2,3})/g, // Simple regexp\r\n        IMAGE_TAG_REGEX = new RegExp('<img\\\\s*' + KEY_VALUE_REGEX + IS_CLOSE_REGEX + '>'),\r\n        WORD_BREAK_REGEX = new RegExp('\\\\W+', 'g'),\r\n        matches = true,\r\n        result,\r\n        index,\r\n        tail,\r\n        tag,\r\n        selfClose;\r\n\r\n    /**\r\n     * Remove image tag\r\n     *\r\n     * @private\r\n     * @method _removeImageTag\r\n     * @param {String} string not-yet-processed string\r\n     * @return {String} string without image tags\r\n     */\r\n    function _removeImageTag(string) {\r\n        var match = IMAGE_TAG_REGEX.exec(string),\r\n            index,\r\n            len;\r\n\r\n        if (!match) {\r\n            return string;\r\n        }\r\n\r\n        index = match.index;\r\n        len = match[0].length;\r\n\r\n        return string.substring(0, index) + string.substring(index + len);\r\n    }\r\n\r\n    /**\r\n     * Dump all close tags and append to truncated content while reaching upperbound\r\n     *\r\n     * @private\r\n     * @method _dumpCloseTag\r\n     * @param {String[]} tags a list of tags which should be closed\r\n     * @return {String} well-formatted html\r\n     */\r\n    function _dumpCloseTag(tags) {\r\n        var html = '';\r\n\r\n        tags.reverse().forEach(function (tag, index) {\r\n            // dump non-excluded tags only\r\n            if (-1 === EXCLUDE_TAGS.indexOf(tag)) {\r\n                html += '</' + tag + '>';\r\n            }\r\n        });\r\n\r\n        return html;\r\n    }\r\n\r\n    /**\r\n     * Process tag string to get pure tag name\r\n     *\r\n     * @private\r\n     * @method _getTag\r\n     * @param {String} string original html\r\n     * @return {String} tag name\r\n     */\r\n    function _getTag(string) {\r\n        var tail = string.indexOf(' ');\r\n\r\n        // TODO:\r\n        // we have to figure out how to handle non-well-formatted HTML case\r\n        if (-1 === tail) {\r\n            tail = string.indexOf('>');\r\n            if (-1 === tail) {\r\n                throw new Error('HTML tag is not well-formed : ' + string);\r\n            }\r\n        }\r\n\r\n        return string.substring(1, tail);\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the end position for String#substring()\r\n     *\r\n     * If options.truncateLastWord is FALSE, we try to the end position up to\r\n     * options.slop characters to avoid breaking in the middle of a word.\r\n     *\r\n     * @private\r\n     * @method _getEndPosition\r\n     * @param {String} string original html\r\n     * @param {Number} tailPos (optional) provided to avoid extending the slop into trailing HTML tag\r\n     * @return {Number} maxLength\r\n     */\r\n    function _getEndPosition (string, tailPos) {\r\n        var defaultPos = maxLength - total,\r\n            position = defaultPos,\r\n            isShort = defaultPos < options.slop,\r\n            slopPos = isShort ? defaultPos : options.slop - 1,\r\n            substr,\r\n            startSlice = isShort ? 0 : defaultPos - options.slop,\r\n            endSlice = tailPos || (defaultPos + options.slop),\r\n            result;\r\n\r\n        if (!options.truncateLastWord) {\r\n\r\n            substr = string.slice(startSlice, endSlice);\r\n\r\n            if (tailPos && substr.length <= tailPos) {\r\n                position = substr.length;\r\n            }\r\n            else {\r\n                while ((result = WORD_BREAK_REGEX.exec(substr)) !== null) {\r\n                    // a natural break position before the hard break position\r\n                    if (result.index < slopPos) {\r\n                        position = defaultPos - (slopPos - result.index);\r\n                        // keep seeking closer to the hard break position\r\n                        // unless a natural break is at position 0\r\n                        if (result.index === 0 && defaultPos <= 1) break;\r\n                    }\r\n                    // a natural break position exactly at the hard break position\r\n                    else if (result.index === slopPos) {\r\n                        position = defaultPos;\r\n                        break; // seek no more\r\n                    }\r\n                    // a natural break position after the hard break position\r\n                    else {\r\n                        position = defaultPos + (result.index - slopPos);\r\n                        break;  // seek no more\r\n                    }\r\n                }\r\n            }\r\n            if (string.charAt(position - 1).match(/\\s$/)) position--;\r\n        }\r\n        return position;\r\n    }\r\n\r\n    options = options || EMPTY_OBJECT;\r\n    options.ellipsis = (undefined !== options.ellipsis) ? options.ellipsis : DEFAULT_TRUNCATE_SYMBOL;\r\n    options.truncateLastWord = (undefined !== options.truncateLastWord) ? options.truncateLastWord : true;\r\n    options.slop = (undefined !== options.slop) ? options.slop : DEFAULT_SLOP;\r\n\r\n    while (matches) {\r\n        matches = HTML_TAG_REGEX.exec(string);\r\n\r\n        if (!matches) {\r\n            if (total >= maxLength) { break; }\r\n\r\n            matches = URL_REGEX.exec(string);\r\n            if (!matches || matches.index >= maxLength) {\r\n                content += string.substring(0, _getEndPosition(string));\r\n                break;\r\n            }\r\n\r\n            while (matches) {\r\n                result = matches[0];\r\n                index = matches.index;\r\n                content += string.substring(0, (index + result.length) - total);\r\n                string = string.substring(index + result.length);\r\n                matches = URL_REGEX.exec(string);\r\n            }\r\n            break;\r\n        }\r\n\r\n        result = matches[0];\r\n        index = matches.index;\r\n\r\n        if (total + index > maxLength) {\r\n            // exceed given `maxLength`, dump everything to clear stack\r\n            content += string.substring(0, _getEndPosition(string, index));\r\n            break;\r\n        } else {\r\n            total += index;\r\n            content += string.substring(0, index);\r\n        }\r\n\r\n        if ('/' === result[1]) {\r\n            // move out open tag\r\n            items.pop();\r\n            selfClose=null;\r\n        } else {\r\n            selfClose = SELF_CLOSE_REGEX.exec(result);\r\n            if (!selfClose) {\r\n                tag = _getTag(result);\r\n\r\n                items.push(tag);\r\n            }\r\n        }\r\n\r\n        if (selfClose) {\r\n            content += selfClose[0];\r\n        } else {\r\n            content += result;\r\n        }\r\n        string = string.substring(index + result.length);\r\n    }\r\n\r\n    if (string.length > maxLength - total && options.ellipsis) {\r\n        content += options.ellipsis;\r\n    }\r\n    content += _dumpCloseTag(items);\r\n\r\n    if (!options.keepImageTag) {\r\n        content = _removeImageTag(content);\r\n    }\r\n\r\n    return content;\r\n}\r\n\r\nmodule.exports = truncate;\r\n"],
  "mappings": "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",
  "names": ["string", "index", "tag", "tail", "result"]
}
