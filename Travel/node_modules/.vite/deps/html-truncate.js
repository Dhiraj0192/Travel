import {
  __commonJS
} from "./chunk-LK32TJAX.js";

// node_modules/html-truncate/lib/truncate.js
var require_truncate = __commonJS({
  "node_modules/html-truncate/lib/truncate.js"(exports, module) {
    function truncate(string, maxLength, options) {
      var EMPTY_OBJECT = {}, EMPTY_STRING = "", DEFAULT_TRUNCATE_SYMBOL = "...", DEFAULT_SLOP = 10 > maxLength ? maxLength : 10, EXCLUDE_TAGS = ["img", "br"], items = [], total = 0, content = EMPTY_STRING, KEY_VALUE_REGEX = '([\\w|-]+\\s*(=\\s*"[^"]*")?\\s*)*', IS_CLOSE_REGEX = "\\s*\\/?\\s*", CLOSE_REGEX = "\\s*\\/\\s*", SELF_CLOSE_REGEX = new RegExp("<\\/?\\w+\\s*" + KEY_VALUE_REGEX + CLOSE_REGEX + ">"), HTML_TAG_REGEX = new RegExp("<\\/?\\w+\\s*" + KEY_VALUE_REGEX + IS_CLOSE_REGEX + ">"), URL_REGEX = /(((ftp|https?):\/\/)[\-\w@:%_\+.~#?,&\/\/=]+)|((mailto:)?[_.\w\-]+@([\w][\w\-]+\.)+[a-zA-Z]{2,3})/g, IMAGE_TAG_REGEX = new RegExp("<img\\s*" + KEY_VALUE_REGEX + IS_CLOSE_REGEX + ">"), WORD_BREAK_REGEX = new RegExp("\\W+", "g"), matches = true, result, index, tail, tag, selfClose;
      function _removeImageTag(string2) {
        var match = IMAGE_TAG_REGEX.exec(string2), index2, len;
        if (!match) {
          return string2;
        }
        index2 = match.index;
        len = match[0].length;
        return string2.substring(0, index2) + string2.substring(index2 + len);
      }
      function _dumpCloseTag(tags) {
        var html = "";
        tags.reverse().forEach(function(tag2, index2) {
          if (-1 === EXCLUDE_TAGS.indexOf(tag2)) {
            html += "</" + tag2 + ">";
          }
        });
        return html;
      }
      function _getTag(string2) {
        var tail2 = string2.indexOf(" ");
        if (-1 === tail2) {
          tail2 = string2.indexOf(">");
          if (-1 === tail2) {
            throw new Error("HTML tag is not well-formed : " + string2);
          }
        }
        return string2.substring(1, tail2);
      }
      function _getEndPosition(string2, tailPos) {
        var defaultPos = maxLength - total, position = defaultPos, isShort = defaultPos < options.slop, slopPos = isShort ? defaultPos : options.slop - 1, substr, startSlice = isShort ? 0 : defaultPos - options.slop, endSlice = tailPos || defaultPos + options.slop, result2;
        if (!options.truncateLastWord) {
          substr = string2.slice(startSlice, endSlice);
          if (tailPos && substr.length <= tailPos) {
            position = substr.length;
          } else {
            while ((result2 = WORD_BREAK_REGEX.exec(substr)) !== null) {
              if (result2.index < slopPos) {
                position = defaultPos - (slopPos - result2.index);
                if (result2.index === 0 && defaultPos <= 1) break;
              } else if (result2.index === slopPos) {
                position = defaultPos;
                break;
              } else {
                position = defaultPos + (result2.index - slopPos);
                break;
              }
            }
          }
          if (string2.charAt(position - 1).match(/\s$/)) position--;
        }
        return position;
      }
      options = options || EMPTY_OBJECT;
      options.ellipsis = void 0 !== options.ellipsis ? options.ellipsis : DEFAULT_TRUNCATE_SYMBOL;
      options.truncateLastWord = void 0 !== options.truncateLastWord ? options.truncateLastWord : true;
      options.slop = void 0 !== options.slop ? options.slop : DEFAULT_SLOP;
      while (matches) {
        matches = HTML_TAG_REGEX.exec(string);
        if (!matches) {
          if (total >= maxLength) {
            break;
          }
          matches = URL_REGEX.exec(string);
          if (!matches || matches.index >= maxLength) {
            content += string.substring(0, _getEndPosition(string));
            break;
          }
          while (matches) {
            result = matches[0];
            index = matches.index;
            content += string.substring(0, index + result.length - total);
            string = string.substring(index + result.length);
            matches = URL_REGEX.exec(string);
          }
          break;
        }
        result = matches[0];
        index = matches.index;
        if (total + index > maxLength) {
          content += string.substring(0, _getEndPosition(string, index));
          break;
        } else {
          total += index;
          content += string.substring(0, index);
        }
        if ("/" === result[1]) {
          items.pop();
          selfClose = null;
        } else {
          selfClose = SELF_CLOSE_REGEX.exec(result);
          if (!selfClose) {
            tag = _getTag(result);
            items.push(tag);
          }
        }
        if (selfClose) {
          content += selfClose[0];
        } else {
          content += result;
        }
        string = string.substring(index + result.length);
      }
      if (string.length > maxLength - total && options.ellipsis) {
        content += options.ellipsis;
      }
      content += _dumpCloseTag(items);
      if (!options.keepImageTag) {
        content = _removeImageTag(content);
      }
      return content;
    }
    module.exports = truncate;
  }
});
export default require_truncate();
//# sourceMappingURL=html-truncate.js.map
